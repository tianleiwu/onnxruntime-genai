#include <iostream>
#include <vector>
#include <cmath>
#include <limits>
#include <algorithm>

namespace Generators {
namespace cuda {

/**
 * @brief Maps a given value to the index of the smallest sampled value that is
 * greater than or equal to it. If the value is larger than any sample, it maps
 * to the index of the largest sample.
 *
 * @param value The value to map.
 * @param samples A sorted vector of the sampled points.
 * @return The mapped index.
 */
int MapToNextSampledIndex(int value, const std::vector<int>& samples) {
    // Find the first sample that is not less than the value.
    auto it = std::lower_bound(samples.begin(), samples.end(), value);

    if (it == samples.end()) {
        // If the value is greater than all samples, return the index of the max sample.
        return samples.size() - 1;
    }
    // Otherwise, return the index of the found sample.
    return std::distance(samples.begin(), it);
}


/**
 * @brief Estimates the k-threshold based on pre-calculated benchmark data.
 *
 * This function first maps the input batch_size and vocab_size to the
 * indices of the nearest valid sample points. It then uses these indices
 * to perform a direct O(1) lookup in a pre-filled, flattened 2D data table.
 *
 * @param batch_size The batch size for the estimation.
 * @param vocab_size The vocabulary size for the estimation.
 * @return The estimated k_threshold.
 */
int EstimateThresholdK(int batch_size, int vocab_size) {
  // --- Generated by topk_benchmark_analysis.py ---
  static const std::vector<int> sampled_batch_sizes = {1, 2, 4, 8};
  static const std::vector<int> sampled_vocab_sizes = {
      512, 1024, 2048, 4096, 8192, 16384, 24576, 32768, 40960, 49152, 57344,
      65536, 81920, 98304, 114688, 131072, 147456, 163840, 180224, 196608, 212992,
      229376, 245760, 262144
  };
  const int num_vocab_sizes = 24;

  // A flattened 2D array of k-thresholds, with shape (4, 24).
  static const std::vector<int> benchmark_data = {
      // Batch Size 1
      2, 2, 2, 6, 10, 12, 16, 12, 12, 12, 12, 12, 10, 8, 10, 8, 8, 6, 6, 6, 6, 6, 6, 4,
      // Batch Size 2
      2, 2, 2, 6, 10, 12, 16, 12, 16, 12, 12, 12, 12, 8, 10, 8, 8, 8, 6, 6, 6, 6, 4, 4,
      // Batch Size 4
      2, 2, 2, 6, 10, 12, 16, 12, 12, 12, 12, 12, 12, 8, 10, 8, 8, 6, 6, 6, 6, 6, 4, 4,
      // Batch Size 8
      2, 2, 2, 6, 8, 12, 16, 12, 12, 12, 12, 10, 10, 8, 8, 8, 8, 8, 8, 8, 8, 6, 6, 6,
  };
  // --- End of generated code ---

    // Map the inputs to the sampled indices.
    int batch_index = MapToNextSampledIndex(batch_size, sampled_batch_sizes);
    int vocab_index = MapToNextSampledIndex(vocab_size, sampled_vocab_sizes);

    // Calculate the index in the flattened 1D data vector.
    int flat_index = batch_index * num_vocab_sizes + vocab_index;

    return benchmark_data[flat_index];
}

}  // namespace cuda
}  // namespace Generators

